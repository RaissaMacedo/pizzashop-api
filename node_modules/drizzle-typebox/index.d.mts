import type { TAny, TArray, TBigInt, TBoolean, TDate, TLiteral, TNull, TNumber, TObject, TOptional, TSchema, TString, TUnion } from '@sinclair/typebox';
import { type Assume, type DrizzleTypeError, type Equal, type Simplify, type Table, type Column } from 'drizzle-orm';
type TUnionLiterals<T extends string[]> = T extends readonly [
    infer U extends string,
    ...infer Rest extends string[]
] ? [TLiteral<U>, ...TUnionLiterals<Rest>] : [];
type Json = typeof jsonSchema;
export declare const jsonSchema: TUnion<[TUnion<[TString, TNumber, TBoolean, TNull]>, TArray<TAny>, import("@sinclair/typebox").TRecord<TString, TAny>]>;
type TNullable<TType extends TSchema> = TUnion<[TType, TNull]>;
type MapInsertColumnToTypebox<TColumn extends Column, TType extends TSchema> = TColumn['_']['notNull'] extends false ? TOptional<TNullable<TType>> : TColumn['_']['hasDefault'] extends true ? TOptional<TType> : TType;
type MapSelectColumnToTypebox<TColumn extends Column, TType extends TSchema> = TColumn['_']['notNull'] extends false ? TNullable<TType> : TType;
type MapColumnToTypebox<TColumn extends Column, TType extends TSchema, TMode extends 'insert' | 'select'> = TMode extends 'insert' ? MapInsertColumnToTypebox<TColumn, TType> : MapSelectColumnToTypebox<TColumn, TType>;
type MaybeOptional<TColumn extends Column, TType extends TSchema, TMode extends 'insert' | 'select', TNoOptional extends boolean> = TNoOptional extends true ? TType : MapColumnToTypebox<TColumn, TType, TMode>;
type GetTypeboxType<TColumn extends Column> = TColumn['_']['dataType'] extends infer TDataType ? TDataType extends 'custom' ? TAny : TDataType extends 'json' ? Json : TColumn extends {
    enumValues: [string, ...string[]];
} ? Equal<TColumn['enumValues'], [string, ...string[]]> extends true ? TString : TUnion<TUnionLiterals<TColumn['enumValues']>> : TDataType extends 'array' ? TArray<GetTypeboxType<Assume<TColumn['_'], {
    baseColumn: Column;
}>['baseColumn']>> : TDataType extends 'bigint' ? TBigInt : TDataType extends 'number' ? TNumber : TDataType extends 'string' ? TString : TDataType extends 'boolean' ? TBoolean : TDataType extends 'date' ? TDate : TAny : never;
type ValueOrUpdater<T, TUpdaterArg> = T | ((arg: TUpdaterArg) => T);
type UnwrapValueOrUpdater<T> = T extends ValueOrUpdater<infer U, any> ? U : never;
export type Refine<TTable extends Table, TMode extends 'select' | 'insert'> = {
    [K in keyof TTable['_']['columns']]?: ValueOrUpdater<TSchema, TMode extends 'select' ? BuildSelectSchema<TTable, {}, true> : BuildInsertSchema<TTable, {}, true>>;
};
export type BuildInsertSchema<TTable extends Table, TRefine extends Refine<TTable, 'insert'> | {}, TNoOptional extends boolean = false> = TTable['_']['columns'] extends infer TColumns extends Record<string, Column<any>> ? {
    [K in keyof TColumns & string]: MaybeOptional<TColumns[K], K extends keyof TRefine ? Assume<UnwrapValueOrUpdater<TRefine[K]>, TSchema> : GetTypeboxType<TColumns[K]>, 'insert', TNoOptional>;
} : never;
export type BuildSelectSchema<TTable extends Table, TRefine extends Refine<TTable, 'select'>, TNoOptional extends boolean = false> = Simplify<{
    [K in keyof TTable['_']['columns']]: MaybeOptional<TTable['_']['columns'][K], K extends keyof TRefine ? Assume<UnwrapValueOrUpdater<TRefine[K]>, TSchema> : GetTypeboxType<TTable['_']['columns'][K]>, 'select', TNoOptional>;
}>;
export declare const Nullable: <T extends TSchema>(schema: T) => TUnion<[T, TNull]>;
export declare function createInsertSchema<TTable extends Table, TRefine extends Refine<TTable, 'insert'> = Refine<TTable, 'insert'>>(table: TTable, 
/**
 * @param refine Refine schema fields
 */
refine?: {
    [K in keyof TRefine]: K extends keyof TTable['_']['columns'] ? TRefine[K] : DrizzleTypeError<`Column '${K & string}' does not exist in table '${TTable['_']['name']}'`>;
}): TObject<BuildInsertSchema<TTable, Equal<TRefine, Refine<TTable, 'insert'>> extends true ? {} : TRefine>>;
export declare function createSelectSchema<TTable extends Table, TRefine extends Refine<TTable, 'select'> = Refine<TTable, 'select'>>(table: TTable, 
/**
 * @param refine Refine schema fields
 */
refine?: {
    [K in keyof TRefine]: K extends keyof TTable['_']['columns'] ? TRefine[K] : DrizzleTypeError<`Column '${K & string}' does not exist in table '${TTable['_']['name']}'`>;
}): TObject<BuildSelectSchema<TTable, Equal<TRefine, Refine<TTable, 'select'>> extends true ? {} : TRefine>>;
export {};
